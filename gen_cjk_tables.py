#!/usr/bin/env python3
"""
Generate cjk_data.h from WHATWG encoding standard index files.

Downloads and parses:
  - index-jis0208.txt
  - index-jis0212.txt
  - index-euc-kr.txt
  - index-gb18030.txt
  - index-gb18030-ranges.txt
  - index-big5.txt

Produces cjk_data.h with decode arrays, sorted encode arrays,
and gb18030 range table.
"""

import os
import sys
import urllib.request
from collections import OrderedDict

BASE_URL = "https://encoding.spec.whatwg.org/"

INDEX_FILES = [
    ("index-jis0208.txt",         "jis0208"),
    ("index-jis0212.txt",         "jis0212"),
    ("index-euc-kr.txt",          "euc_kr"),
    ("index-gb18030.txt",         "gb18030"),
    ("index-big5.txt",            "big5"),
]

RANGES_FILE = ("index-gb18030-ranges.txt", "gb18030_ranges")

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
OUTPUT_FILE = os.path.join(SCRIPT_DIR, "cjk_data.h")
CACHE_DIR = os.path.join(SCRIPT_DIR, ".index_cache")


def download(filename):
    """Download a file from WHATWG, caching locally."""
    os.makedirs(CACHE_DIR, exist_ok=True)
    cached = os.path.join(CACHE_DIR, filename)
    if os.path.exists(cached):
        print("  Using cached {}".format(cached))
        with open(cached, "r", encoding="utf-8") as f:
            return f.read()
    url = BASE_URL + filename
    print("  Downloading {} ...".format(url))
    req = urllib.request.Request(url, headers={"User-Agent": "gen_cjk_tables/1.0"})
    with urllib.request.urlopen(req, timeout=30) as resp:
        data = resp.read().decode("utf-8")
    with open(cached, "w", encoding="utf-8") as f:
        f.write(data)
    return data


def parse_index(text):
    """Parse a WHATWG index file. Returns list of (pointer, codepoint) tuples."""
    entries = []
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split("\t")
        if len(parts) < 2:
            parts = line.split()
        if len(parts) < 2:
            continue
        pointer = int(parts[0].strip())
        cp_str = parts[1].strip()
        if cp_str.startswith("0x") or cp_str.startswith("0X"):
            codepoint = int(cp_str, 16)
        else:
            codepoint = int(cp_str)
        entries.append((pointer, codepoint))
    return entries


def parse_ranges(text):
    """Parse gb18030-ranges.txt. Returns list of (pointer, codepoint) tuples."""
    entries = []
    for line in text.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split("\t")
        if len(parts) < 2:
            parts = line.split()
        if len(parts) < 2:
            continue
        pointer = int(parts[0].strip())
        cp_str = parts[1].strip()
        if cp_str.startswith("0x") or cp_str.startswith("0X"):
            codepoint = int(cp_str, 16)
        else:
            codepoint = int(cp_str)
        entries.append((pointer, codepoint))
    return entries


def main():
    print("gen_cjk_tables.py: Generating CJK encoding tables")
    print()

    # Collect all index data
    all_indices = OrderedDict()
    for filename, name in INDEX_FILES:
        print("Processing {} -> {}".format(filename, name))
        text = download(filename)
        entries = parse_index(text)
        all_indices[name] = entries
        max_ptr = max(p for p, c in entries)
        print("  {} entries, max pointer = {}".format(len(entries), max_ptr))

    # Ranges
    print("Processing {} -> {}".format(RANGES_FILE[0], RANGES_FILE[1]))
    ranges_text = download(RANGES_FILE[0])
    ranges_entries = parse_ranges(ranges_text)
    print("  {} range entries".format(len(ranges_entries)))
    print()

    # Generate output
    lines = []
    w = lines.append

    w("/* cjk_data.h - Auto-generated by gen_cjk_tables.py */")
    w("/* Do not edit manually. */")
    w("")
    w("#ifndef CJK_DATA_H")
    w("#define CJK_DATA_H")
    w("")
    w("#include <stdint.h>")
    w("")
    w("struct cjk_encode_entry {")
    w("    uint32_t codepoint;")
    w("    uint16_t pointer;")
    w("};")
    w("")
    w("struct gb18030_range {")
    w("    uint32_t pointer;")
    w("    uint32_t codepoint;")
    w("};")
    w("")

    stats = {}

    for name, entries in all_indices.items():
        max_pointer = max(p for p, c in entries)

        # -- Decode array --
        decode_size = max_pointer + 1
        decode_map = {}
        for p, c in entries:
            decode_map[p] = c

        w("/* {}: {} mappings, max pointer {} */".format(name, len(entries), max_pointer))
        w("static const uint32_t {}_decode[{}] = {{".format(name, decode_size))

        # Write in rows of 8
        row = []
        for i in range(decode_size):
            val = decode_map.get(i, 0)
            if val:
                row.append("0x{:04X}".format(val))
            else:
                row.append("0")
            if len(row) == 8:
                w("    " + ", ".join(row) + ",")
                row = []
        if row:
            w("    " + ", ".join(row) + ",")
        w("};")
        w("")

        # -- Encode array (sorted by codepoint) --
        # For duplicate codepoints, keep the first (lowest pointer) per WHATWG spec
        encode_map = {}
        for p, c in entries:
            if c not in encode_map or p < encode_map[c]:
                encode_map[c] = p
        encode_list = sorted(encode_map.items())  # sorted by codepoint

        w("static const struct cjk_encode_entry {}_encode[{}] = {{".format(name, len(encode_list)))
        for cp, ptr in encode_list:
            w("    {{0x{:04X}, {}}},".format(cp, ptr))
        w("};")
        w("")

        stats[name] = {
            "mappings": len(entries),
            "decode_size": decode_size,
            "encode_size": len(encode_list),
        }

    # -- GB18030 ranges --
    w("/* gb18030_ranges: {} range entries */".format(len(ranges_entries)))
    w("static const struct gb18030_range gb18030_ranges[{}] = {{".format(len(ranges_entries)))
    for ptr, cp in ranges_entries:
        w("    {{{}, 0x{:04X}}},".format(ptr, cp))
    w("};")
    w("")

    # Convenience size macros
    w("/* Array size constants */")
    for name, st in stats.items():
        w("#define {}_DECODE_SIZE {}".format(name.upper(), st["decode_size"]))
        w("#define {}_ENCODE_SIZE {}".format(name.upper(), st["encode_size"]))
    w("#define GB18030_RANGES_SIZE {}".format(len(ranges_entries)))
    w("")

    w("#endif /* CJK_DATA_H */")
    w("")

    # Write output
    output = "\n".join(lines)
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write(output)

    total_lines = len(lines)
    file_size = len(output.encode("utf-8"))

    print("Written: {}".format(OUTPUT_FILE))
    print("Total lines: {}".format(total_lines))
    print("File size: {:,} bytes ({:.1f} MB)".format(file_size, file_size / 1024 / 1024))
    print()
    print("Array summary:")
    print("  {:<16} {:>8} {:>15} {:>15}".format("Name", "Mappings", "Decode entries", "Encode entries"))
    print("  {:<16} {:>8} {:>15} {:>15}".format("-" * 16, "-" * 8, "-" * 15, "-" * 15))
    for name, st in stats.items():
        print("  {:<16} {:>8} {:>15,} {:>15,}".format(name, st["mappings"], st["decode_size"], st["encode_size"]))
    print("  {:<16} {:>8} {:>15} {:>15}".format("gb18030_ranges", len(ranges_entries), "(range table)", ""))


if __name__ == "__main__":
    main()
